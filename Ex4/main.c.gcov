        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:1
        -:    1:// C program for Dijkstra's single source shortest path
        -:    2:// algorithm. The program is for adjacency matrix
        -:    3:// representation of the graph
        -:    4:
        -:    5:#include <limits.h>
        -:    6:#include <stdbool.h>
        -:    7:#include <stdio.h>
        -:    8:#include <stdlib.h>
        -:    9:
        -:   10:// A utility function to find the vertex with minimum
        -:   11:// distance value, from the set of vertices not yet included
        -:   12:// in shortest path tree
        2:   13:int minDistance(int dist[], bool sptSet[], int size)
        -:   14:{
        -:   15:    // Initialize min value
        2:   16:    int min = INT_MAX, min_index;
        -:   17:
        8:   18:    for (int v = 0; v < size; v++)
        6:   19:        if (sptSet[v] == false && dist[v] <= min)
        2:   20:            min = dist[v], min_index = v;
        -:   21:
        2:   22:    return min_index;
        -:   23:}
        -:   24:
        -:   25:// A utility function to print the constructed distance
        -:   26:// array
        1:   27:void printSolution(int dist[], int size)
        -:   28:{
        1:   29:    printf("Vertex \t\t Distance from Source\n");
        4:   30:    for (int i = 0; i < size; i++)
        3:   31:        printf("%d \t\t\t\t %d\n", i, dist[i]);
        1:   32:}
        -:   33:
        -:   34:// Function that implements Dijkstra's single source
        -:   35:// shortest path algorithm for a graph represented using
        -:   36:// adjacency matrix representation
        1:   37:void dijkstra(int **graph, int src, int size)
        -:   38:{
        -:   39:    // malloc the dist and sptSet arrays
        1:   40:    int *dist = (int *)malloc(size * sizeof(int)); // The output array. dist[i] will hold the shortest distance from src to i
        -:   41:
        1:   42:    bool *sptSet = (bool *)malloc(size * sizeof(bool)); // sptSet[i] will be true if vertex i is included in shortest path tree or shortest distance from src to i is finalized
        -:   43:
        -:   44:    // Initialize all distances as INFINITE and stpSet[] as
        -:   45:    // false
        4:   46:    for (int i = 0; i < size; i++)
        3:   47:        dist[i] = INT_MAX, sptSet[i] = false;
        -:   48:
        -:   49:    // Distance of source vertex from itself is always 0
        1:   50:    dist[src] = 0;
        -:   51:
        -:   52:    // Find shortest path for all vertices
        3:   53:    for (int count = 0; count < size - 1; count++)
        -:   54:    {
        -:   55:        // Pick the minimum distance vertex from the set of
        -:   56:        // vertices not yet processed. u is always equal to
        -:   57:        // src in the first iteration.
        2:   58:        int u = minDistance(dist, sptSet, size);
        -:   59:
        -:   60:        // Mark the picked vertex as processed
        2:   61:        sptSet[u] = true;
        -:   62:
        -:   63:        // Update dist value of the adjacent vertices of the
        -:   64:        // picked vertex.
        8:   65:        for (int v = 0; v < size; v++)
        -:   66:
        -:   67:            // Update dist[v] only if is not in sptSet,
        -:   68:            // there is an edge from u to v, and total
        -:   69:            // weight of path from src to v through u is
        -:   70:            // smaller than current value of dist[v]
        6:   71:            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
        2:   72:                dist[v] = dist[u] + graph[u][v];
        -:   73:    }
        -:   74:
        -:   75:    // print the constructed distance array
        1:   76:    printSolution(dist, size);
        1:   77:}
        -:   78:
        -:   79:// driver's code
        1:   80:int main()
        -:   81:{
        1:   82:    int weight = 0, rows = 0, cols = 0;
        -:   83:    /* Let us create the example graph discussed above */
        -:   84:    // int graph[V][V] = {{0,  4, 0,  0,  0,  0, 0,  8, 0},
        -:   85:    //                    {4,  0, 8,  0,  0,  0, 0, 11, 0},
        -:   86:    //                    {0,  8, 0,  7,  0,  4, 0,  0, 2},
        -:   87:    //                    {0,  0, 7,  0,  9, 14, 0,  0, 0},
        -:   88:    //                    {0,  0, 0,  9,  0, 10, 0,  0, 0},
        -:   89:    //                    {0,  0, 4, 14, 10,  0, 2,  0, 0},
        -:   90:    //                    {0,  0, 0,  0,  0,  2, 0,  1, 6},
        -:   91:    //                    {8, 11, 0,  0,  0,  0, 1,  0, 7},
        -:   92:    //                    {0,  0, 2,  0,  0,  0, 6,  7, 0}};
        -:   93:
        -:   94:    // build the graph using the user input
        -:   95:    int **graph;
        -:   96:
        1:   97:    printf("Enter the number of rows: ");
        1:   98:	scanf("%d", &rows);
        1:   99:	printf("Enter the number of columns: ");
        1:  100:	scanf("%d", &cols);
        -:  101:
        1:  102:    if(rows < 0 || cols < 0 || rows != cols)
        -:  103:	{
    #####:  104:		printf("Invalid input. The number of rows and columns must be positive and equal.\n");
    #####:  105:		return 1;
        -:  106:	}
        -:  107:
        -:  108:    // allocate memory for the graph
        1:  109:    graph = (int **)malloc(rows * sizeof(int *));
        4:  110:    for (int i = 0; i < rows; i++)
        -:  111:    {
        3:  112:        graph[i] = (int *)malloc(cols * sizeof(int));
        -:  113:    }
        -:  114:
        4:  115:    for (int i = 0; i < rows; i++)
        -:  116:    {
        9:  117:        for (int j = i; j < cols; j++)
        -:  118:        {
        6:  119:            printf("Enter the weight of the edge between %d and %d: ", i, j);
        6:  120:            scanf("%d", &weight);
        -:  121:
        6:  122:            if (weight < 0)
        -:  123:            {
    #####:  124:                printf("Weight can't be negative");
    #####:  125:                return 1;
        -:  126:            }
        6:  127:            graph[i][j] = weight;
        6:  128:            graph[j][i] = weight;
        -:  129:        }
        -:  130:    }
        -:  131:
        -:  132:    // Function call
        1:  133:    dijkstra(graph, 0, rows);
        -:  134:
        1:  135:    return 0;
        -:  136:}
