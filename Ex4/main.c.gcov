        -:    0:Colorization: profile count: [46m[Kzero coverage (exceptional)[m[K [41m[Kzero coverage (unexceptional)[m[K [45m[Kunexecuted block[m[K
        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:1
        -:    1:// C program for Dijkstra's single source shortest path
        -:    2:// algorithm. The program is for adjacency matrix
        -:    3:// representation of the graph
        -:    4:
        -:    5:#include <limits.h>
        -:    6:#include <stdbool.h>
        -:    7:#include <stdio.h>
        -:    8:#include <stdlib.h>
        -:    9:#include <string.h>
        -:   10:
        -:   11:// A utility function to find the vertex with minimum
        -:   12:// distance value, from the set of vertices not yet included
        -:   13:// in shortest path tree
        2:   14:int minDistance(int dist[], bool sptSet[], int size)
        -:   15:{
        -:   16:    // Initialize min value
        2:   17:    int min = INT_MAX, min_index;
        -:   18:
        8:   19:    for (int v = 0; v < size; v++)
        6:   20:        if (sptSet[v] == false && dist[v] <= min)
        2:   21:            min = dist[v], min_index = v;
        -:   22:
        2:   23:    return min_index;
        -:   24:}
        -:   25:
        -:   26:// A utility function to print the constructed distance
        -:   27:// array
        1:   28:void printSolution(int dist[], int size)
        -:   29:{
        1:   30:    printf("Vertex \t\t Distance from Source\n");
        4:   31:    for (int i = 0; i < size; i++)
        3:   32:        printf("%d \t\t\t\t %d\n", i, dist[i]);
        1:   33:}
        -:   34:
        -:   35:// Function that implements Dijkstra's single source
        -:   36:// shortest path algorithm for a graph represented using
        -:   37:// adjacency matrix representation
        1:   38:void dijkstra(int **graph, int src, int size)
        -:   39:{
        -:   40:    // malloc the dist and sptSet arrays
        1:   41:    int *dist = (int *)malloc(size * sizeof(int)); // The output array. dist[i] will hold the shortest distance from src to i
        -:   42:
        1:   43:    bool *sptSet = (bool *)malloc(size * sizeof(bool)); // sptSet[i] will be true if vertex i is included in shortest path tree or shortest distance from src to i is finalized
        -:   44:
        -:   45:    // Initialize all distances as INFINITE and stpSet[] as
        -:   46:    // false
        4:   47:    for (int i = 0; i < size; i++)
        3:   48:        dist[i] = INT_MAX, sptSet[i] = false;
        -:   49:
        -:   50:    // Distance of source vertex from itself is always 0
        1:   51:    dist[src] = 0;
        -:   52:
        -:   53:    // Find shortest path for all vertices
        3:   54:    for (int count = 0; count < size - 1; count++)
        -:   55:    {
        -:   56:        // Pick the minimum distance vertex from the set of
        -:   57:        // vertices not yet processed. u is always equal to
        -:   58:        // src in the first iteration.
        2:   59:        int u = minDistance(dist, sptSet, size);
        -:   60:
        -:   61:        // Mark the picked vertex as processed
        2:   62:        sptSet[u] = true;
        -:   63:
        -:   64:        // Update dist value of the adjacent vertices of the
        -:   65:        // picked vertex.
        8:   66:        for (int v = 0; v < size; v++)
        -:   67:
        -:   68:            // Update dist[v] only if is not in sptSet,
        -:   69:            // there is an edge from u to v, and total
        -:   70:            // weight of path from src to v through u is
        -:   71:            // smaller than current value of dist[v]
        6:   72:            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
        1:   73:                dist[v] = dist[u] + graph[u][v];
        -:   74:    }
        -:   75:
        -:   76:    // print the constructed distance array
        1:   77:    printSolution(dist, size);
        1:   78:}
        -:   79:
        3:   80:char* myGetLine(char* data)
        -:   81:{
        3:   82:    data = NULL;
        3:   83:    size_t len = 0;
        3:   84:    getline(&data, &len, stdin);
        3:   85:    data[strcspn(data, "\r\n")] = 0;
        3:   86:    return data;
        -:   87:}
        -:   88:
        -:   89:// driver's code
        1:   90:int main(int argc, char **argv)
        -:   91:{
        -:   92:
        -:   93:    /* Let us create the example graph discussed above */
        -:   94:    // int graph[V][V] = {{0,  4, 0,  0,  0,  0, 0,  8, 0},
        -:   95:    //                    {4,  0, 8,  0,  0,  0, 0, 11, 0},
        -:   96:    //                    {0,  8, 0,  7,  0,  4, 0,  0, 2},
        -:   97:    //                    {0,  0, 7,  0,  9, 14, 0,  0, 0},
        -:   98:    //                    {0,  0, 0,  9,  0, 10, 0,  0, 0},
        -:   99:    //                    {0,  0, 4, 14, 10,  0, 2,  0, 0},
        -:  100:    //                    {0,  0, 0,  0,  0,  2, 0,  1, 6},
        -:  101:    //                    {8, 11, 0,  0,  0,  0, 1,  0, 7},
        -:  102:    //                    {0,  0, 2,  0,  0,  0, 6,  7, 0}};
        -:  103:
        -:  104:    // build the graph using the user input
        1:  105:    int weight = 0, rows = 0, cols = 0;
        1:  106:    printf("Enter the number of rows: ");
        1:  107:	scanf("%d", &rows);getchar();
        1:  108:	printf("Enter the number of columns: ");
        1:  109:	scanf("%d", &cols);getchar();    
        -:  110:
        1:  111:    if(rows < 0 || cols < 0 || rows != cols)
        -:  112:	{
[41;37m[K        0[m[K:  113:		printf("Invalid input. The number of rows and columns must be positive and equal. exiting\n");
[41;37m[K        0[m[K:  114:		exit(1);
        -:  115:	}
        -:  116:
        -:  117:    // allocate memory for the graph
        1:  118:    int **graph = (int **)malloc(rows * sizeof(int *));
        4:  119:    for (int i = 0; i < rows; i++)
        -:  120:    {
        3:  121:        graph[i] = (int *)malloc(cols * sizeof(int));
        -:  122:    }
        -:  123:
        4:  124:    for (int i = 0; i < rows; i++)
        -:  125:    {
        3:  126:        printf("Enter the weight for line %d\n", i + 1);
        3:  127:        char *weight_str = NULL;
        3:  128:        weight_str = myGetLine(weight_str);
        -:  129:        // if (x == EOF)
        -:  130:        // {
        -:  131:        //     printf("Invalid input. unexpected EOF, not enough values. exiting\n");
        -:  132:        //     exit(1);
        -:  133:        // }
        -:  134:        // parse the input using strtok with the delimiter space
        3:  135:        char *token = strtok(weight_str, " ");
        3:  136:        int j = 0;
       12:  137:        for (j = 0; j < cols; j++)
        -:  138:        {
        9:  139:            if (token) {weight = atoi(token);}
        9:  140:            if (weight < 0)
        -:  141:            {
[41;37m[K        0[m[K:  142:                printf("Weight can't be negative. exiting\n");
[41;37m[K        0[m[K:  143:                exit(1);
        -:  144:            }
        -:  145:
        9:  146:            graph[i][j] = weight;
        9:  147:            token = strtok(NULL, " ");
        -:  148:        }
        3:  149:        if(token == NULL && j < cols)
        -:  150:        {
[41;37m[K        0[m[K:  151:            printf("Invalid amount of values in row\n");
[41;37m[K        0[m[K:  152:            exit(1);
        -:  153:        }
        3:  154:        if(token != NULL && j == cols - 1)
        -:  155:        {
[41;37m[K        0[m[K:  156:            printf("Invalid amount of values in row\n");
[41;37m[K        0[m[K:  157:            exit(1);
        -:  158:        }
        -:  159:    }
        -:  160:
        -:  161:    // Function call
        1:  162:    dijkstra(graph, 0, rows);
        -:  163:
        1:  164:    return 0;
        -:  165:}
